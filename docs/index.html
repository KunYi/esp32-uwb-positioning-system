<!DOCTYPE html>
<html lang="zh-en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UWB Positioning Visualization | UWB 定位視覺化展示</title>

    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 引入 React 和 ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    <style>
        .katex { font-size: 1.1em; }
        .math-display { margin: 1em 0; overflow-x: auto; }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const Card = ({ children, className }) => (
            <div className={`bg-white rounded-lg shadow-lg overflow-hidden ${className}`}>
                {children}
            </div>
        );

        const CardHeader = ({ children }) => (
            <div className="p-6 border-b">{children}</div>
        );

        const CardTitle = ({ children }) => (
            <h2 className="text-2xl font-bold mb-4">{children}</h2>
        );

        const CardContent = ({ children }) => (
            <div className="p-6">{children}</div>
        );

        const Select = ({ value, onChange, children }) => (
            <select
                value={value}
                onChange={(e) => onChange(e.target.value)}
                className="w-full p-2 border rounded-md bg-white"
            >
                {children}
            </select>
        );

        const Slider = ({ value, onChange, min, max, step }) => (
            <input
                type="range"
                value={value}
                onChange={(e) => onChange(parseFloat(e.target.value))}
                min={min}
                max={max}
                step={step}
                className="w-full"
            />
        );

        const UWBVisualization = () => {
            const [method, setMethod] = React.useState('two');
            const [time, setTime] = React.useState(0);
            const [tagPosition, setTagPosition] = React.useState('inside');
            const [radius, setRadius] = React.useState(50);
            const [controlMode, setControlMode] = React.useState('auto');
            const [manualPosition, setManualPosition] = React.useState({ x: 200, y: 200 });
            const [isDragging, setIsDragging] = React.useState(false);
            const svgRef = React.useRef(null);

            // 定義基站位置配置
            const anchorConfigs = {
                two: [
                    { x: 100, y: 200 },  // 左側基站
                    { x: 300, y: 200 },  // 右側基站，拉開距離
                ],
                three: [
                    { x: 133, y: 267 },  // 左側基站
                    { x: 267, y: 267 },  // 右側基站
                    { x: 200, y: 133 },  // 頂部基站
                ],
                many: [
                    { x: 100, y: 160 },  // 左上基站
                    { x: 300, y: 133 },  // 右上基站
                    { x: 300, y: 267 },  // 右下基站
                    { x: 100, y: 267 },  // 左下基站
                ]
            };

            // 動畫效果
            React.useEffect(() => {
                if (controlMode === 'auto') {
                    const timer = setInterval(() => {
                        setTime(prev => (prev + 1) % 100);
                    }, 50);
                    return () => clearInterval(timer);
                }
            }, [controlMode]);

            // 處理拖曳開始
            const handleMouseDown = (e) => {
                if (controlMode === 'manual') {
                    setIsDragging(true);
                    const svg = svgRef.current;
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                    setManualPosition({ x: svgP.x, y: svgP.y });
                }
            };

            // 處理拖曳移動
            const handleMouseMove = (e) => {
                if (isDragging && controlMode === 'manual') {
                    const svg = svgRef.current;
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                    setManualPosition({ x: svgP.x, y: svgP.y });
                }
            };

            // 處理拖曳結束
            const handleMouseUp = () => {
                setIsDragging(false);
            };

            // 計算Tag位置
            const getTagPosition = () => {
                if (controlMode === 'manual') {
                    return manualPosition;
                }

                const centerX = 200;
                const centerY = 200;

                if (tagPosition === 'inside') {
                    return {
                        x: centerX + Math.cos(time * 0.1) * radius,
                        y: centerY + Math.sin(time * 0.1) * radius
                    };
                } else {
                    return {
                        x: centerX + Math.cos(time * 0.1) * (radius + 100),
                        y: centerY + Math.sin(time * 0.1) * (radius + 100)
                    };
                }
            };

            // 像素轉換為米的比例（1像素 = 0.15米）
            const pixelToMeter = (pixels) => {
                const ratio = 0.15;
                return (pixels * ratio).toFixed(2);  // 保持兩位小數的精確度
            };

            // 格式化狀態文字
            const formatStatus = (value, unit = '') => {
                return `${value}${unit} | ${value}${unit}`;
            };

            // 計算兩點之間的距離
            const getDistance = (p1, p2) => {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                return Math.sqrt(dx * dx + dy * dy);
            };

            // 根據距離決定顏色
            const getDistanceColor = (distance) => {
                const maxGoodDistance = 200;  // 30米
                if (distance <= maxGoodDistance) {
                    return "rgba(0,255,0,0.2)";  // 綠色 - 良好範圍
                } else if (distance <= maxGoodDistance * 1.5) {
                    return "rgba(255,165,0,0.2)";  // 橙色 - 警告範圍
                } else {
                    return "rgba(255,0,0,0.2)";  // 紅色 - 較差範圍
                }
            };

            // 繪製圓形路徑
            const getCirclePath = (anchor, distance) => {
                return `M ${anchor.x} ${anchor.y} m -${distance}, 0 a ${distance},${distance} 0 1,0 ${distance*2},0 a ${distance},${distance} 0 1,0 -${distance*2},0`;
            };

            // 計算定位誤差
            const getPositioningError = () => {
                const tag = getTagPosition();
                const anchors = anchorConfigs[method];
                return anchors.reduce((sum, anchor) => {
                    const dx = tag.x - anchor.x;
                    const dy = tag.y - anchor.y;
                    return sum + Math.sqrt(dx * dx + dy * dy);
                }, 0) / anchors.length;
            };

            const tag = getTagPosition();

            // 在組件掛載後渲染數學公式
            React.useEffect(() => {
                const renderMath = () => {
                    document.querySelectorAll('.math-display').forEach(element => {
                        const formula = element.getAttribute('data-math');
                        try {
                            katex.render(formula, element, {
                                displayMode: true,
                                throwOnError: false
                            });
                        } catch (e) {
                            console.error('KaTeX error:', e);
                            element.textContent = formula;
                        }
                    });
                };
                
                // 確保 KaTeX 已加載
                if (window.katex) {
                    renderMath();
                } else {
                    // 如果 KaTeX 還沒加載完成，等待一下再試
                    setTimeout(renderMath, 1000);
                }
            }, [method]);  // 當 method 改變時重新渲染

            const [angle, setAngle] = React.useState(0);
            const [speed, setSpeed] = React.useState(1);

            return (
                <div className="container mx-auto px-4 py-8">
                    <Card className="max-w-4xl mx-auto">
                        <CardHeader>
                            <CardTitle>UWB Positioning Demo (Inside/Outside Range) | UWB 定位演示（內部/外部範圍）</CardTitle>
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">
                                        Control Mode | 控制模式
                                    </label>
                                    <Select value={controlMode} onChange={setControlMode}>
                                        <option value="auto">Automatic Movement | 自動移動</option>
                                        <option value="manual">Manual Control (Drag) | 手動控制（拖曳）</option>
                                    </Select>
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">
                                        Positioning Method | 定位方法
                                    </label>
                                    <Select value={method} onChange={setMethod}>
                                        <option value="two">Two Anchors | 兩個基站</option>
                                        <option value="three">Three Anchors | 三個基站</option>
                                        <option value="many">Multiple Anchors | 多個基站</option>
                                    </Select>
                                </div>
                                {controlMode === 'auto' && (
                                    <div>
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-1">
                                                Tag Position | 標籤位置
                                            </label>
                                            <div className="mt-1">
                                                <input
                                                    type="range"
                                                    min="0"
                                                    max="360"
                                                    value={angle}
                                                    onChange={(e) => setAngle(Number(e.target.value))}
                                                    className="w-full"
                                                />
                                            </div>
                                        </div>
                                        <div className="mt-4">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">
                                                Speed | 速度
                                            </label>
                                            <div className="mt-1">
                                                <input
                                                    type="range"
                                                    min="1"
                                                    max="10"
                                                    value={speed}
                                                    onChange={(e) => setSpeed(Number(e.target.value))}
                                                    className="w-full"
                                                />
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </CardHeader>
                        <CardContent>
                            <div className="relative w-full h-96 bg-slate-50 rounded-lg">
                                <svg 
                                    width="100%" 
                                    height="100%" 
                                    viewBox="0 0 400 400"
                                    ref={svgRef}
                                    onMouseDown={handleMouseDown}
                                    onMouseMove={handleMouseMove}
                                    onMouseUp={handleMouseUp}
                                    onMouseLeave={handleMouseUp}
                                    style={{ cursor: controlMode === 'manual' ? 'grab' : 'default' }}
                                >
                                    {/* 覆蓋區域 */}
                                    <polygon
                                        points={anchorConfigs[method].map(p => `${p.x},${p.y}`).join(' ')}
                                        fill="rgba(0,0,255,0.1)"
                                        stroke="rgba(0,0,255,0.8)"
                                        strokeWidth="2"
                                    />

                                    {/* 基站之間的連線 */}
                                    {method === 'two' && (
                                        <line
                                            x1={anchorConfigs[method][0].x}
                                            y1={anchorConfigs[method][0].y}
                                            x2={anchorConfigs[method][1].x}
                                            y2={anchorConfigs[method][1].y}
                                            stroke="rgba(0,0,255,0.8)"
                                            strokeWidth="2"
                                        />
                                    )}
                                    {method === 'three' && anchorConfigs[method].map((anchor, i) => (
                                        <line
                                            key={i}
                                            x1={anchor.x}
                                            y1={anchor.y}
                                            x2={anchorConfigs[method][(i + 1) % 3].x}
                                            y2={anchorConfigs[method][(i + 1) % 3].y}
                                            stroke="rgba(0,0,255,0.8)"
                                            strokeWidth="2"
                                        />
                                    ))}
                                    {method === 'many' && (
                                        <g>
                                            <line x1={anchorConfigs[method][0].x} y1={anchorConfigs[method][0].y} 
                                                  x2={anchorConfigs[method][1].x} y2={anchorConfigs[method][1].y} 
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                            <line x1={anchorConfigs[method][1].x} y1={anchorConfigs[method][1].y}
                                                  x2={anchorConfigs[method][2].x} y2={anchorConfigs[method][2].y}
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                            <line x1={anchorConfigs[method][2].x} y1={anchorConfigs[method][2].y}
                                                  x2={anchorConfigs[method][3].x} y2={anchorConfigs[method][3].y}
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                            <line x1={anchorConfigs[method][3].x} y1={anchorConfigs[method][3].y}
                                                  x2={anchorConfigs[method][0].x} y2={anchorConfigs[method][0].y}
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                        </g>
                                    )}

                                    {/* 基站和距離圓 */}
                                    {anchorConfigs[method].map((anchor, index) => (
                                        <g key={index}>
                                            {/* 距離圓 */}
                                            <path
                                                d={getCirclePath(anchor, getDistance(anchor, tag))}
                                                fill="none"
                                                stroke={getDistanceColor(getDistance(anchor, tag))}
                                                strokeWidth="2"
                                            />
                                            {/* 基站點 */}
                                            <circle
                                                cx={anchor.x}
                                                cy={anchor.y}
                                                r="6"
                                                fill="blue"
                                            />
                                            <text
                                                x={anchor.x + 10}
                                                y={anchor.y - 10}
                                                fontSize="12"
                                            >
                                                Anchor {index + 1}
                                            </text>
                                            {/* 距離線 */}
                                            <line
                                                x1={anchor.x}
                                                y1={anchor.y}
                                                x2={tag.x}
                                                y2={tag.y}
                                                stroke="rgba(255,165,0,0.6)"
                                                strokeWidth="1.5"
                                                strokeDasharray="4,4"
                                            />
                                            {/* 距離文字背景 */}
                                            <rect
                                                x={(anchor.x + tag.x) / 2 - 25}
                                                y={(anchor.y + tag.y) / 2 - 10}
                                                width="50"
                                                height="20"
                                                fill="white"
                                                rx="4"
                                            />
                                            {/* 距離文字 */}
                                            <text
                                                x={(anchor.x + tag.x) / 2}
                                                y={(anchor.y + tag.y) / 2 + 5}
                                                fontSize="12"
                                                fill="black"
                                                textAnchor="middle"
                                            >
                                                {pixelToMeter(getDistance(anchor, tag))}m
                                            </text>
                                        </g>
                                    ))}

                                    {/* Tag */}
                                    <circle
                                        cx={tag.x}
                                        cy={tag.y}
                                        r="8"
                                        fill="red"
                                    />
                                    <text
                                        x={tag.x + 15}
                                        y={tag.y}
                                        fontSize="12"
                                    >
                                        Tag
                                    </text>
                                </svg>
                            </div>
                            <div className="mt-4 space-y-2 text-sm">
                                <p>Current Status | 當前狀態：{controlMode === 'manual' ? 'Manual Control | 手動控制' : 'Inside Range | 基站範圍內'}</p>
                                <p>Average Distance | 平均距離：{pixelToMeter(getPositioningError())}m</p>
                                {method === 'two' && (
                                    <p>Two-Anchor Positioning | 兩基站定位：
                                        {tagPosition === 'inside' ? 
                                            'May have two solutions | 可能有兩個解' : 
                                            'Positioning accuracy decreases when outside range | 在範圍外時定位精度下降'}
                                    </p>
                                )}
                                {method === 'three' && (
                                    <p>Three-Anchor Positioning | 三基站定位：
                                        {tagPosition === 'inside' ? 
                                            'Unique solution available | 有唯一解' : 
                                            'Solution may be less accurate outside range | 在範圍外時解可能不太準確'}
                                    </p>
                                )}
                                {method === 'many' && (
                                    <p>Multi-Anchor Positioning | 多基站定位：
                                        {tagPosition === 'inside' ? 
                                            'Higher accuracy with redundant measurements | 冗餘測量提高精度' : 
                                            'Better accuracy even outside range | 即使在範圍外也有較好的精度'}
                                    </p>
                                )}
                            </div>
                            {/* 定位原理說明 */}
                            <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                                <h3 className="font-bold mb-2">Positioning Principles | 定位原理</h3>
                                <div className="space-y-4">
                                    <div>
                                        <p className="mb-1">Distance Calculation | 距離計算：</p>
                                        <p className="font-mono">d = c × t</p>
                                        <p className="text-xs text-gray-600 mt-1">
                                            Distance is calculated using Time of Flight (TOF) principle | 使用飛行時間原理計算距離：
                                            <br/>• d: distance between anchor and tag | 基站和標籤之間的距離
                                            <br/>• c: speed of light (≈ 3×10⁸ m/s) | 光速（約 3×10⁸ 米/秒）
                                            <br/>• t: time taken for signal to travel from anchor to tag and back | 信號從基站到標籤往返的時間
                                            <br/>UWB achieves high accuracy by precise time measurement in nanoseconds | UWB通過納秒級精確時間測量實現高精度
                                        </p>
                                    </div>

                                    <div>
                                        <p className="mb-1">Position Calculation | 位置計算：</p>
                                        <p className="font-mono">(x-x₁)² + (y-y₁)² = d₁²</p>
                                        <p className="text-xs text-gray-600 mt-1">
                                            Based on the circle equation, where | 基於圓方程，其中：
                                            <br/>• (x,y): unknown tag position to be found | 待求的標籤位置
                                            <br/>• (x₁,y₁): known anchor position | 已知的基站位置
                                            <br/>• d₁: measured distance between anchor and tag | 測量的基站和標籤之間距離
                                            <br/>Each anchor creates a circle, tag must lie on this circle | 每個基站形成一個圓，標籤必須位於圓上
                                        </p>
                                    </div>

                                    {method === 'two' && (
                                        <div>
                                            <p className="mb-1">Two Anchor Solution | 兩基站解算：</p>
                                            <p className="text-xs text-gray-600 mt-1">
                                                Two anchors create two circles | 兩個基站形成兩個圓：
                                                <br/>• Circles intersect at 0, 1, or 2 points | 圓可能有0、1或2個交點
                                                <br/>• Two intersection points: need additional information to choose correct one | 兩個交點：需要額外信息來選擇正確的點
                                                <br/>• One intersection point: circles are tangent (rare case) | 一個交點：圓相切（罕見情況）
                                                <br/>• No intersection: measurement error or out of range | 無交點：測量誤差或超出範圍
                                                <br/>Usually requires a third anchor or height information to resolve ambiguity | 通常需要第三個基站或高度信息來解決歧義
                                            </p>
                                        </div>
                                    )}

                                    {method === 'three' && (
                                        <div>
                                            <p className="mb-1">Trilateration | 三邊定位：</p>
                                            <p className="font-mono whitespace-pre-line">
                                                (x-x₁)² + (y-y₁)² = d₁²
                                                (x-x₂)² + (y-y₂)² = d₂²
                                                (x-x₃)² + (y-y₃)² = d₃²
                                            </p>
                                            <p className="text-xs text-gray-600 mt-1">
                                                Three anchors provide unique solution | 三個基站提供唯一解：
                                                <br/>• System of three circle equations | 三個圓方程組成的系統
                                                <br/>• Theoretically intersect at one point | 理論上在一點相交
                                                <br/>• In practice, measurement errors create small area | 實際上由於測量誤差形成小區域
                                                <br/>• Best position estimate is center of intersection area | 最佳位置估計在交集區域中心
                                                <br/>• Accuracy depends on anchor geometry and measurement precision | 精度取決於基站幾何分布和測量精度
                                            </p>
                                        </div>
                                    )}

                                    {method === 'many' && (
                                        <div>
                                            <p className="mb-1">Multilateration | 多邊定位：</p>
                                            <p>Least squares optimization | 最小二乘法優化：</p>
                                            <p className="font-mono">min Σ[(x-xᵢ)² + (y-yᵢ)² - dᵢ²]²</p>
                                            <p className="text-xs text-gray-600 mt-1">
                                                Multiple anchors improve accuracy | 多個基站提高精度：
                                                <br/>• Minimizes sum of squared errors | 最小化誤差平方和
                                                <br/>• Each anchor adds redundant measurement | 每個基站增加冗餘測量
                                                <br/>• Reduces impact of individual measurement errors | 減少單個測量誤差的影響
                                                <br/>• More anchors generally improve accuracy | 更多基站通常提高精度
                                                <br/>• Optimal anchor placement: surrounding tag position | 最佳基站布置：圍繞標籤位置
                                                <br/>• Iterative solution using numerical methods | 使用數值方法進行迭代求解
                                            </p>
                                        </div>
                                    )}
                                </div>
                            </div>
                            <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                                <h3 className="font-bold mb-2">Error Analysis | 誤差分析</h3>
                                <div className="space-y-4">
                                    <div>
                                        <p className="mb-1">Error Sources | 誤差來源：</p>
                                        <div className="text-xs text-gray-600 mt-1">
                                            <p className="font-semibold">1. Hardware Errors | 硬件誤差</p>
                                            <ul className="list-disc pl-4 mb-2">
                                                <li>Clock drift between anchors and tags | 基站和標籤之間的時鐘漂移</li>
                                                <li>Antenna phase center variation | 天線相位中心變化</li>
                                                <li>Temperature effects on electronics | 溫度對電子元件的影響</li>
                                            </ul>

                                            <p className="font-semibold">2. Environmental Errors | 環境誤差</p>
                                            <ul className="list-disc pl-4 mb-2">
                                                <li>Multipath effects | 多徑效應</li>
                                                <li>Signal blocking and reflection | 信號阻擋和反射</li>
                                                <li>Non-line-of-sight (NLOS) conditions | 非視線傳播條件</li>
                                            </ul>

                                            <p className="font-semibold">3. Geometric Errors | 幾何誤差</p>
                                            <ul className="list-disc pl-4 mb-2">
                                                <li>Poor anchor geometry (GDOP) | 基站幾何分布不佳</li>
                                                <li>Height difference effects | 高度差異影響</li>
                                                <li>Anchor position uncertainty | 基站位置不確定性</li>
                                            </ul>
                                        </div>
                                    </div>

                                    <div>
                                        <p className="mb-1">Error Mitigation | 誤差處理：</p>
                                        <div className="text-xs text-gray-600 mt-1">
                                            <p className="font-semibold">1. Hardware Calibration | 硬件校準</p>
                                            <ul className="list-disc pl-4 mb-2">
                                                <li>Antenna delay calibration | 天線延遲校準</li>
                                                <li>Temperature compensation | 溫度補償</li>
                                                <li>Clock synchronization | 時鐘同步</li>
                                            </ul>

                                            <p className="font-semibold">2. Signal Processing | 信號處理</p>
                                            <ul className="list-disc pl-4 mb-2">
                                                <li>Channel impulse response analysis | 信道衝擊響應分析</li>
                                                <li>First path detection | 首徑檢測</li>
                                                <li>NLOS identification | 非視距識別</li>
                                            </ul>

                                            <p className="font-semibold">3. Algorithm Enhancement | 算法增強</p>
                                            <ul className="list-disc pl-4 mb-2">
                                                <li>Kalman filtering | 卡爾曼濾波</li>
                                                <li>Weighted least squares | 加權最小二乘</li>
                                                <li>NLOS mitigation algorithms | 非視距緩解算法</li>
                                            </ul>

                                            <p className="font-semibold">4. System Design | 系統設計</p>
                                            <ul className="list-disc pl-4 mb-2">
                                                <li>Optimal anchor placement | 最優基站布置</li>
                                                <li>Redundant measurements | 冗餘測量</li>
                                                <li>Dynamic error thresholding | 動態誤差閾值</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </CardContent>
                    </Card>
                </div>
            );
        };

        // 渲染應用
        ReactDOM.render(<UWBVisualization />, document.getElementById('root'));
    </script>
</body>
</html>
