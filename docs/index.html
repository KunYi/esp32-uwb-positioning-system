<!DOCTYPE html>
<html lang="zh-en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UWB Positioning Visualization | UWB 定位視覺化展示</title>
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" as="script">
    <link rel="preload" href="https://unpkg.com/react@18/umd/react.development.js" as="script">
    <link rel="preload" href="https://unpkg.com/react-dom@18/umd/react-dom.development.js" as="script">

    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 引入 React 和 ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: true,
                packages: ['base', 'ams', 'noerrors', 'noundefined']
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                typeset: true,
                ready: () => {
                    MathJax.startup.defaultReady();
                }
            },
            options: {
                enableMenu: false
            }
        };
    </script>
    <script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <style>
        .math-display {
            margin: 1em 0;
            overflow-x: auto;
        }
        .mjx-math {
            font-size: 1.1em;
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- GitHub Corner -->
    <a href="https://github.com/KunYi/esp32-uwb-positioning-system" class="github-corner" aria-label="View source on GitHub">
        <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
            <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
        </svg>
        <style>
            .github-corner:hover .octo-arm {
                animation: octocat-wave 560ms ease-in-out;
            }
            @keyframes octocat-wave {
                0%, 100% { transform: rotate(0); }
                20%, 60% { transform: rotate(-25deg); }
                40%, 80% { transform: rotate(10deg); }
            }
            @media (max-width: 500px) {
                .github-corner:hover .octo-arm {
                    animation: none;
                }
                .github-corner .octo-arm {
                    animation: octocat-wave 560ms ease-in-out;
                }
            }
        </style>
    </a>
    <div id="root"></div>

    <script type="text/babel">
        const Card = ({ children, className }) => (
            <div className={`bg-white rounded-lg shadow-lg overflow-hidden ${className}`}>
                {children}
            </div>
        );

        const CardHeader = ({ children }) => (
            <div className="p-6 border-b">{children}</div>
        );

        const CardTitle = ({ children }) => (
            <h2 className="text-2xl font-bold mb-4">{children}</h2>
        );

        const CardContent = ({ children }) => (
            <div className="p-6">{children}</div>
        );

        const Select = ({ value, onChange, children }) => (
            <select
                value={value}
                onChange={(e) => onChange(e.target.value)}
                className="w-full p-2 border rounded-md bg-white"
            >
                {children}
            </select>
        );

        const Slider = ({ value, onChange, min, max, step }) => (
            <input
                type="range"
                value={value}
                onChange={(e) => onChange(parseFloat(e.target.value))}
                min={min}
                max={max}
                step={step}
                className="w-full"
            />
        );

        const MathDisplay = ({ tex, displayMode = true, className }) => {
            const containerRef = React.useRef(null);

            React.useEffect(() => {
                const renderMath = async () => {
                    if (!containerRef.current || !tex) return;

                    // 等待 MathJax 完全加載
                    if (!window.MathJax || !window.MathJax.typesetPromise) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        if (!window.MathJax || !window.MathJax.typesetPromise) {
                            console.warn('MathJax not loaded properly');
                            containerRef.current.textContent = tex;
                            return;
                        }
                    }

                    try {
                        containerRef.current.innerHTML = displayMode ? `$$${tex}$$` : `$${tex}$`;
                        await window.MathJax.typesetPromise([containerRef.current]);
                    } catch (err) {
                        console.error('MathJax rendering error:', err);
                        containerRef.current.textContent = tex;
                    }
                };

                renderMath();
            }, [tex, displayMode]);

            return <div ref={containerRef} className={`${className} math-display`}></div>;
        };

        const UWBVisualization = () => {
            const [method, setMethod] = React.useState('two');
            const [time, setTime] = React.useState(0);
            const [tagPosition, setTagPosition] = React.useState('inside');
            const [radius, setRadius] = React.useState(50);
            const [controlMode, setControlMode] = React.useState('auto');
            const [manualPosition, setManualPosition] = React.useState({ x: 200, y: 200 });
            const [isDragging, setIsDragging] = React.useState(false);
            const [angle, setAngle] = React.useState(0);  // 用於調整半徑的偏移量
            const svgRef = React.useRef(null);

            // 定義基站位置配置
            const anchorConfigs = {
                two: [
                    { x: 100, y: 200 },  // 左側基站
                    { x: 300, y: 200 },  // 右側基站，拉開距離
                ],
                three: [
                    { x: 133, y: 267 },  // 左側基站
                    { x: 267, y: 267 },  // 右側基站
                    { x: 200, y: 133 },  // 頂部基站
                ],
                many: [
                    { x: 100, y: 160 },  // 左上基站
                    { x: 300, y: 133 },  // 右上基站
                    { x: 300, y: 267 },  // 右下基站
                    { x: 100, y: 267 },  // 左下基站
                ]
            };

            // 處理拖曳開始
            const handleMouseDown = (e) => {
                if (controlMode === 'manual') {
                    setIsDragging(true);
                    const svg = svgRef.current;
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                    setManualPosition({ x: svgP.x, y: svgP.y });
                }
            };

            // 處理拖曳移動
            const handleMouseMove = (e) => {
                if (isDragging && controlMode === 'manual') {
                    const svg = svgRef.current;
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                    setManualPosition({ x: svgP.x, y: svgP.y });
                }
            };

            // 處理拖曳結束
            const handleMouseUp = () => {
                setIsDragging(false);
            };

            // 計算Tag位置
            const getTagPosition = () => {
                if (controlMode === 'manual') {
                    return manualPosition;
                }

                const centerX = 200;
                const centerY = 200;
                const radiusOffset = angle;  // 使用 angle 作為半徑的偏移量

                if (tagPosition === 'inside') {
                    return {
                        x: centerX + Math.cos(time * 0.1) * (radius + radiusOffset),
                        y: centerY + Math.sin(time * 0.1) * (radius + radiusOffset)
                    };
                } else {
                    return {
                        x: centerX + Math.cos(time * 0.1) * (radius + 100 + radiusOffset),
                        y: centerY + Math.sin(time * 0.1) * (radius + 100 + radiusOffset)
                    };
                }
            };

            // 像素轉換為米的比例（1像素 = 0.15米）
            const pixelToMeter = (pixels) => {
                const ratio = 0.15;
                return (pixels * ratio).toFixed(2);  // 保持兩位小數的精確度
            };

            // 格式化狀態文字
            const formatStatus = (value, unit = '') => {
                return `${value}${unit} | ${value}${unit}`;
            };

            // 計算兩點之間的距離
            const getDistance = (p1, p2) => {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                return Math.sqrt(dx * dx + dy * dy);
            };

            // 根據距離決定顏色
            const getDistanceColor = (distance) => {
                const maxGoodDistance = 200;  // 30米
                if (distance <= maxGoodDistance) {
                    return "rgba(0,255,0,0.2)";  // 綠色 - 良好範圍
                } else if (distance <= maxGoodDistance * 1.5) {
                    return "rgba(255,165,0,0.2)";  // 橙色 - 警告範圍
                } else {
                    return "rgba(255,0,0,0.2)";  // 紅色 - 較差範圍
                }
            };

            // 繪製圓形路徑
            const getCirclePath = (anchor, distance) => {
                return `M ${anchor.x} ${anchor.y} m -${distance}, 0 a ${distance},${distance} 0 1,0 ${distance*2},0 a ${distance},${distance} 0 1,0 -${distance*2},0`;
            };

            // 計算定位誤差
            const getPositioningError = () => {
                const tag = getTagPosition();
                const anchors = anchorConfigs[method];
                return anchors.reduce((sum, anchor) => {
                    const dx = tag.x - anchor.x;
                    const dy = tag.y - anchor.y;
                    return sum + Math.sqrt(dx * dx + dy * dy);
                }, 0) / anchors.length;
            };

            const tag = getTagPosition();

            // 動畫效果
            React.useEffect(() => {
                if (controlMode === 'auto') {
                    const timer = setInterval(() => {
                        setTime(prev => (prev + 1) % 100);
                    }, 50);
                    return () => clearInterval(timer);
                }
            }, [controlMode]);

            React.useEffect(() => {
                if (window.MathJax && window.MathJax.typeset) {
                    try {
                        window.MathJax.typeset();
                    } catch (err) {
                        console.error('MathJax error:', err);
                    }
                }
            }, [method]); // 當方法改變時重新渲染公式

            return (
                <div className="container mx-auto px-4 py-8">
                    <Card className="max-w-4xl mx-auto">
                        <CardHeader>
                            <CardTitle>UWB Positioning Demo | UWB 定位演示</CardTitle>
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">
                                        Control Mode | 控制模式
                                    </label>
                                    <Select value={controlMode} onChange={setControlMode}>
                                        <option value="auto">Automatic Movement | 自動移動</option>
                                        <option value="manual">Manual Control (Drag) | 手動控制（拖曳）</option>
                                    </Select>
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">
                                        Positioning Method | 定位方法
                                    </label>
                                    <Select value={method} onChange={setMethod}>
                                        <option value="two">Two Anchors | 兩個基站</option>
                                        <option value="three">Three Anchors | 三個基站</option>
                                        <option value="many">Multiple Anchors | 多個基站</option>
                                    </Select>
                                </div>
                                {controlMode === 'auto' && (
                                    <div>
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-1">
                                                Tag Position | 標籤位置
                                            </label>
                                            <div className="mt-1">
                                                <input
                                                    type="range"
                                                    min="-10"
                                                    max="30"
                                                    value={angle}
                                                    onChange={(e) => setAngle(Number(e.target.value))}
                                                    className="w-full"
                                                />
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </CardHeader>
                        <CardContent>
                            <div className="relative w-full h-96 bg-slate-50 rounded-lg">
                                <svg
                                    width="100%"
                                    height="100%"
                                    viewBox="0 0 400 400"
                                    ref={svgRef}
                                    onMouseDown={handleMouseDown}
                                    onMouseMove={handleMouseMove}
                                    onMouseUp={handleMouseUp}
                                    onMouseLeave={handleMouseUp}
                                    style={{ cursor: controlMode === 'manual' ? 'grab' : 'default' }}
                                >
                                    {/* 覆蓋區域 */}
                                    <polygon
                                        points={anchorConfigs[method].map(p => `${p.x},${p.y}`).join(' ')}
                                        fill="rgba(0,0,255,0.1)"
                                        stroke="rgba(0,0,255,0.8)"
                                        strokeWidth="2"
                                    />

                                    {/* 基站之間的連線 */}
                                    {method === 'two' && (
                                        <line
                                            x1={anchorConfigs[method][0].x}
                                            y1={anchorConfigs[method][0].y}
                                            x2={anchorConfigs[method][1].x}
                                            y2={anchorConfigs[method][1].y}
                                            stroke="rgba(0,0,255,0.8)"
                                            strokeWidth="2"
                                        />
                                    )}
                                    {method === 'three' && anchorConfigs[method].map((anchor, i) => (
                                        <line
                                            key={i}
                                            x1={anchor.x}
                                            y1={anchor.y}
                                            x2={anchorConfigs[method][(i + 1) % 3].x}
                                            y2={anchorConfigs[method][(i + 1) % 3].y}
                                            stroke="rgba(0,0,255,0.8)"
                                            strokeWidth="2"
                                        />
                                    ))}
                                    {method === 'many' && (
                                        <g>
                                            <line x1={anchorConfigs[method][0].x} y1={anchorConfigs[method][0].y}
                                                  x2={anchorConfigs[method][1].x} y2={anchorConfigs[method][1].y}
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                            <line x1={anchorConfigs[method][1].x} y1={anchorConfigs[method][1].y}
                                                  x2={anchorConfigs[method][2].x} y2={anchorConfigs[method][2].y}
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                            <line x1={anchorConfigs[method][2].x} y1={anchorConfigs[method][2].y}
                                                  x2={anchorConfigs[method][3].x} y2={anchorConfigs[method][3].y}
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                            <line x1={anchorConfigs[method][3].x} y1={anchorConfigs[method][3].y}
                                                  x2={anchorConfigs[method][0].x} y2={anchorConfigs[method][0].y}
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                        </g>
                                    )}

                                    {/* 基站和距離圓 */}
                                    {anchorConfigs[method].map((anchor, index) => (
                                        <g key={index}>
                                            {/* 距離圓 */}
                                            <path
                                                d={getCirclePath(anchor, getDistance(anchor, tag))}
                                                fill="none"
                                                stroke={getDistanceColor(getDistance(anchor, tag))}
                                                strokeWidth="2"
                                            />
                                            {/* 基站點 */}
                                            <circle
                                                cx={anchor.x}
                                                cy={anchor.y}
                                                r="6"
                                                fill="blue"
                                            />
                                            <text
                                                x={anchor.x + 10}
                                                y={anchor.y - 10}
                                                fontSize="12"
                                            >
                                                Anchor {index + 1}
                                            </text>
                                            {/* 距離線 */}
                                            <line
                                                x1={anchor.x}
                                                y1={anchor.y}
                                                x2={tag.x}
                                                y2={tag.y}
                                                stroke="rgba(255,165,0,0.6)"
                                                strokeWidth="1.5"
                                                strokeDasharray="4,4"
                                            />
                                            {/* 距離文字背景 */}
                                            <rect
                                                x={(anchor.x + tag.x) / 2 - 25}
                                                y={(anchor.y + tag.y) / 2 - 10}
                                                width="50"
                                                height="20"
                                                fill="white"
                                                rx="4"
                                            />
                                            {/* 距離文字 */}
                                            <text
                                                x={(anchor.x + tag.x) / 2}
                                                y={(anchor.y + tag.y) / 2 + 5}
                                                fontSize="12"
                                                fill="black"
                                                textAnchor="middle"
                                            >
                                                {pixelToMeter(getDistance(anchor, tag))}m
                                            </text>
                                        </g>
                                    ))}

                                    {/* Tag */}
                                    <circle
                                        cx={tag.x}
                                        cy={tag.y}
                                        r="8"
                                        fill="red"
                                    />
                                    <text
                                        x={tag.x + 15}
                                        y={tag.y}
                                        fontSize="12"
                                    >
                                        Tag
                                    </text>
                                </svg>
                            </div>
                            <div className="mt-4 space-y-2 text-sm">
                                <p>Current Status | 當前狀態：{controlMode === 'manual' ? 'Manual Control | 手動控制' : 'Inside Range | 基站範圍內'}</p>
                                <p>Average Distance | 平均距離：{pixelToMeter(getPositioningError())}m</p>
                                {method === 'two' && (
                                    <p>Two-point Positioning | 雙點定位：
                                        {tagPosition === 'inside' ?
                                            'May have two solutions | 可能有兩個解' :
                                            'Positioning accuracy decreases when outside range | 在範圍外時定位精度下降'}
                                    </p>
                                )}
                                {method === 'three' && (
                                    <p>Three-Anchor Positioning | 三基站定位：
                                        {tagPosition === 'inside' ?
                                            'Unique solution available | 有唯一解' :
                                            'Solution may be less accurate outside range | 在範圍外時解可能不太準確'}
                                    </p>
                                )}
                                {method === 'many' && (
                                    <p>Multi-Anchor Positioning | 多基站定位：
                                        {tagPosition === 'inside' ?
                                            'Higher accuracy with redundant measurements | 冗餘測量提高精度' :
                                            'Better accuracy even outside range | 即使在範圍外也有較好的精度'}
                                    </p>
                                )}
                            </div>
                            {/* 定位原理說明 */}
                            <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                                <h3 className="font-bold mb-2">Positioning Principles | 定位原理</h3>
                                <div className="space-y-4">
                                    {/* TWR Explanation Section */}
                                    <div className="mt-8">
                                        <h4 className="font-bold mb-2">Ranging Methods | 測距方法</h4>

                                        {/* SS-TWR */}
                                        <div className="mb-6">
                                            <h5 className="font-semibold mb-2">SS-TWR (Single-Sided Two Way Ranging)</h5>
                                            <p className="mb-4">
                                                SS-TWR is a basic two-way ranging method that measures the round-trip time between two devices.
                                                <br/><br/>
                                                SS-TWR 是一種基本的雙向測距方法，用於測量兩個設備之間的往返時間。
                                            </p>
                                            <div className="bg-gray-50 p-4 rounded-lg mb-4">
                                                <h6 className="font-semibold mb-2">Calculation Principle | 計算原理</h6>
                                                <div className="space-y-2">
                                                    <p>Time of Flight calculation | 飛行時間計算：</p>
                                                    <MathDisplay tex="T_{prop} = \frac{T_{round} - T_{reply}}{2}" displayMode={true} />
                                                    <p className="text-sm text-gray-600">
                                                        Where | 其中：
                                                        <br/>• T<sub>prop</sub>: Time of flight | 飛行時間
                                                        <br/>• T<sub>round</sub> = T<sub>4</sub> - T<sub>1</sub>: Round trip time | 往返總時間
                                                        <br/>• T<sub>reply</sub> = T<sub>3</sub> - T<sub>2</sub>: Reply delay | 回覆延遲時間
                                                    </p>
                                                    <div className="mt-2">
                                                        <p className="text-sm text-gray-600">
                                                            <span className="font-semibold">Key Points | 重點說明：</span>
                                                            <br/>• No clock synchronization required - each device only measures its own time differences | 不需要時鐘同步 - 每個設備只測量自己的時間差
                                                            <br/>• Initiator measures (T<sub>4</sub> - T<sub>1</sub>) and Responder measures (T<sub>3</sub> - T<sub>2</sub>) | 發起方測量 (T<sub>4</sub> - T<sub>1</sub>)，響應方測量 (T<sub>3</sub> - T<sub>2</sub>)
                                                            <br/>• Clock drift between devices may still affect accuracy | 設備間的時鐘漂移仍可能影響精度
                                                            <br/>• Accuracy depends on reply delay stability | 精度取決於回覆延遲的穩定性
                                                        </p>
                                                    </div>
                                                </div>
                                            </div>
                                            <div className="relative h-60 bg-white rounded-lg p-4 mb-2">
                                                <svg className="w-full h-full" viewBox="0 0 400 160">
                                                    {/* Initiator and Responder */}
                                                    <circle cx="50" cy="80" r="10" fill="#4B5563"/>
                                                    <circle cx="350" cy="80" r="10" fill="#4B5563"/>
                                                    <text x="50" y="14" textAnchor="middle" className="text-sm">Initiator</text>
                                                    <text x="350" y="14" textAnchor="middle" className="text-sm">Responder</text>

                                                    {/* Vertical timelines */}
                                                    <line x1="50" y1="20" x2="50" y2="140" stroke="#666" strokeWidth="1" strokeDasharray="2,2"/>
                                                    <line x1="350" y1="20" x2="350" y2="140" stroke="#666" strokeWidth="1" strokeDasharray="2,2"/>

                                                    {/* Time labels with connecting lines */}
                                                    <g className="time-labels">
                                                        {/* T1 */}
                                                        <text x="30" y="40" className="text-xs" textAnchor="end">T1</text>
                                                        <line x1="35" y1="37" x2="50" y2="37" stroke="#666" strokeWidth="1"/>
                                                        {/* T2 */}
                                                        <text x="370" y="60" className="text-xs" textAnchor="start">T2</text>
                                                        <line x1="350" y1="57" x2="365" y2="57" stroke="#666" strokeWidth="1"/>
                                                        {/* T3 */}
                                                        <text x="370" y="100" className="text-xs" textAnchor="start">T3</text>
                                                        <line x1="350" y1="97" x2="365" y2="97" stroke="#666" strokeWidth="1"/>
                                                        {/* T4 */}
                                                        <text x="30" y="120" className="text-xs" textAnchor="end">T4</text>
                                                        <line x1="35" y1="117" x2="50" y2="117" stroke="#666" strokeWidth="1"/>
                                                    </g>

                                                    {/* Processing time indicator */}
                                                    <line x1="350" y1="57" x2="350" y2="97" stroke="#666" strokeWidth="4" opacity="0.2"/>
                                                    <text x="370" y="80" className="text-xs" fill="#666">Processing</text>

                                                    {/* Animated arrows */}
                                                    <g className="ranging-animation">
                                                        {/* Poll message (T1->T2) */}
                                                        <g>
                                                            <path d="M60,37 L340,57" stroke="#10B981" strokeWidth="2" strokeDasharray="290" strokeDashoffset="290" opacity="0">
                                                                <animate id="pollLineShow" attributeName="opacity" values="0;1" dur="0.1s" begin="0s;resetAnim.end" fill="freeze"/>
                                                                <animate id="pollAnim" attributeName="stroke-dashoffset" from="290" to="0" dur="1.5s" begin="pollLineShow.end" repeatCount="1"/>
                                                                <animate attributeName="stroke-dashoffset" to="290" dur="0.1s" begin="resetAnim.end" fill="freeze"/>
                                                                <animate attributeName="opacity" values="1;0" dur="0.1s" begin="processAnim.begin" fill="freeze"/>
                                                            </path>
                                                            {/* Moving arrow head for Poll */}
                                                            <path d="M0,0 l-8,4 v-8 z" fill="#10B981" opacity="0">
                                                                <animate attributeName="opacity" values="0;1" dur="0.1s" begin="pollLineShow.end" fill="freeze"/>
                                                                <animate attributeName="opacity" values="1;0" dur="0.1s" begin="processAnim.begin" fill="freeze"/>
                                                                <animateMotion dur="1.5s" begin="pollLineShow.end" repeatCount="1"
                                                                    path="M60,37 L340,57" rotate="auto"/>
                                                            </path>
                                                        </g>

                                                        {/* Processing indication */}
                                                        <rect x="345" y="57" width="10" height="40" fill="#666" opacity="0">
                                                            <animate id="processAnim" attributeName="opacity" values="0.2;0.5;0.2" dur="0.5s" begin="pollAnim.end" repeatCount="2"/>
                                                        </rect>

                                                        {/* Response message (T3->T4) */}
                                                        <g>
                                                            <path d="M340,97 L60,117" stroke="#DC2626" strokeWidth="2" strokeDasharray="290" strokeDashoffset="290" opacity="0">
                                                                <animate id="responseLineShow" attributeName="opacity" values="0;1" dur="0.1s" begin="processAnim.end" fill="freeze"/>
                                                                <animate id="responseAnim" attributeName="stroke-dashoffset" from="290" to="0" dur="1.5s" begin="responseLineShow.end" repeatCount="1"/>
                                                                <animate attributeName="stroke-dashoffset" to="290" dur="0.1s" begin="resetAnim.end" fill="freeze"/>
                                                                <animate attributeName="opacity" values="1;0" dur="0.1s" begin="resetAnim.begin" fill="freeze"/>
                                                            </path>
                                                            {/* Moving arrow head for Response */}
                                                            <path d="M0,0 l-8,4 v-8 z" fill="#DC2626" opacity="0">
                                                                <animate attributeName="opacity" values="0;1" dur="0.1s" begin="responseLineShow.end" fill="freeze"/>
                                                                <animate attributeName="opacity" values="1;0" dur="0.1s" begin="resetAnim.begin" fill="freeze"/>
                                                                <animateMotion dur="1.5s" begin="responseLineShow.end" repeatCount="1"
                                                                    path="M340,97 L60,117" rotate="auto"/>
                                                            </path>
                                                        </g>

                                                        {/* Arrival indicators */}
                                                        <circle cx="350" cy="57" r="3" fill="#10B981" opacity="0">
                                                            <animate attributeName="opacity" values="0;1" dur="0.1s" begin="pollAnim.end" fill="freeze"/>
                                                            <animate attributeName="opacity" values="1;0" dur="0.1s" begin="processAnim.end" fill="freeze"/>
                                                        </circle>
                                                        <circle cx="50" cy="117" r="3" fill="#DC2626" opacity="0">
                                                            <animate attributeName="opacity" values="0;1" dur="0.1s" begin="responseAnim.end" fill="freeze"/>
                                                            <animate attributeName="opacity" values="1;0" dur="0.1s" begin="resetAnim.begin" fill="freeze"/>
                                                        </circle>

                                                        {/* Animation reset trigger */}
                                                        <animate id="resetAnim" attributeName="opacity" from="1" to="1" dur="0.1s" begin="responseAnim.end+0.5s" repeatCount="1"/>
                                                    </g>

                                                    {/* Message labels */}
                                                    <text x="200" y="45" textAnchor="middle" className="text-xs" fill="#10B981">Poll</text>
                                                    <text x="200" y="102" textAnchor="middle" className="text-xs" fill="#DC2626">Response</text>
                                                </svg>
                                            </div>
                                            <div className="text-sm space-y-2">
                                                <p>Steps | 步驟：</p>
                                                <ol className="list-decimal list-inside space-y-1 pl-4">
                                                    <li>Initiator sends poll message (T1) | 發起者發送輪詢訊息</li>
                                                    <li>Responder receives poll (T2) | 應答者接收輪詢訊息</li>
                                                    <li>Responder sends response (T3) | 應答者發送回應訊息</li>
                                                    <li>Initiator receives response (T4) | 發起者接收回應訊息</li>
                                                </ol>
                                                <div className="katex-formula">
                                                    T<sub>prop</sub> = (T<sub>round</sub> - T<sub>reply</sub>)/2
                                                </div>
                                                <p className="text-xs text-gray-600">
                                                    Time of flight calculation | 飛行時間計算
                                                </p>
                                            </div>
                                        </div>

                                        {/* DS-ATWR */}
                                        <div className="mb-8">
                                            <h5 className="font-bold mb-2">DS-ATWR (Double-Sided Asymmetric Two Way Ranging)</h5>
                                            <p className="mb-4">
                                                DS-ATWR (Double-Sided Asymmetric Two Way Ranging) is an improved two-way ranging technique that enhances ranging accuracy through bidirectional message exchange between two devices. Compared to SS-TWR, DS-ATWR provides better compensation for clock drift, resulting in higher precision. This method is particularly suitable for applications requiring high-precision positioning.
                                                <br/><br/>
                                                DS-ATWR (雙向非對稱雙程測距) 是一種改進的雙向測距技術。與 SS-TWR 相比，DS-ATWR 通過在兩個設備之間進行雙向的訊息交換，可以更好地補償時鐘漂移的影響，從而提高測距精度。這種方法特別適合於需要高精度定位的應用場景。
                                            </p>
                                            <div className="bg-gray-50 p-4 rounded-lg mb-4">
                                                <h6 className="font-semibold mb-2">Calculation Principle | 計算原理</h6>
                                                <div className="space-y-2">
                                                    <p>Time of Flight calculation | 飛行時間計算：</p>
                                                    <MathDisplay tex="T_{prop} = \frac{(T_4 - T_1)(T_6 - T_3) - (T_3 - T_2)(T_5 - T_4)}{2(T_4 - T_1 + T_6 - T_3)}" displayMode={true} />
                                                    <p className="text-sm text-gray-600">
                                                        Where | 其中：
                                                        <br/>• T<sub>prop</sub>: Time of flight | 飛行時間
                                                        <br/>• T<sub>1</sub>, T<sub>4</sub>: First round-trip timestamps at initiator | 發起方第一次往返時間戳
                                                        <br/>• T<sub>2</sub>, T<sub>3</sub>: First round-trip timestamps at responder | 響應方第一次往返時間戳
                                                        <br/>• T<sub>5</sub>, T<sub>6</sub>: Second round-trip timestamps | 第二次往返時間戳
                                                    </p>
                                                    <div className="mt-2">
                                                        <p className="text-sm text-gray-600">
                                                            <span className="font-semibold">Advantages | 優勢：</span>
                                                            <br/>• Compensates for clock drift between devices | 補償設備間的時鐘漂移
                                                            <br/>• Reduces error from asymmetric reply delays | 減少非對稱回覆延遲造成的誤差
                                                            <br/>• Higher accuracy than SS-TWR | 比 SS-TWR 具有更高的精度
                                                        </p>
                                                        <p className="text-sm text-gray-600 mt-2">
                                                            <span className="font-semibold">How it works | 工作原理：</span>
                                                            <br/>1. Initiator sends first poll message (T1) | 發起方發送第一個輪詢訊息 (T1)
                                                            <br/>2. Responder receives and replies (T2, T3) | 響應方接收並回覆 (T2, T3)
                                                            <br/>3. Initiator completes first round (T4) | 發起方完成第一輪 (T4)
                                                            <br/>4. Second round exchange (T5, T6) | 進行第二輪交換 (T5, T6)
                                                            <br/>5. Formula combines all timestamps to calculate accurate flight time | 公式結合所有時間戳計算準確的飛行時間
                                                        </p>
                                                    </div>
                                                </div>
                                            </div>
                                            <div className="relative h-60 bg-white rounded-lg p-4 mb-2">
                                                <svg className="w-full h-full" viewBox="0 0 400 160">
                                                    {/* Initiator and Responder */}
                                                    <circle cx="50" cy="80" r="10" fill="#4B5563"/>
                                                    <circle cx="350" cy="80" r="10" fill="#4B5563"/>
                                                    <text x="50" y="14" textAnchor="middle" className="text-sm">Initiator</text>
                                                    <text x="350" y="14" textAnchor="middle" className="text-sm">Responder</text>

                                                    {/* Vertical timelines */}
                                                    <line x1="50" y1="20" x2="50" y2="140" stroke="#666" strokeWidth="1" strokeDasharray="2,2"/>
                                                    <line x1="350" y1="20" x2="350" y2="140" stroke="#666" strokeWidth="1" strokeDasharray="2,2"/>

                                                    {/* Time labels with connecting lines */}
                                                    <g className="time-labels">
                                                        {/* T1 */}
                                                        <text x="30" y="40" className="text-xs" textAnchor="end">T1</text>
                                                        <line x1="35" y1="37" x2="50" y2="37" stroke="#666" strokeWidth="1"/>
                                                        {/* T2 */}
                                                        <text x="370" y="60" className="text-xs" textAnchor="start">T2</text>
                                                        <line x1="350" y1="57" x2="365" y2="57" stroke="#666" strokeWidth="1"/>
                                                        {/* T3 */}
                                                        <text x="370" y="100" className="text-xs" textAnchor="start">T3</text>
                                                        <line x1="350" y1="97" x2="365" y2="97" stroke="#666" strokeWidth="1"/>
                                                        {/* T4 */}
                                                        <text x="30" y="120" className="text-xs" textAnchor="end">T4</text>
                                                        <line x1="35" y1="117" x2="50" y2="117" stroke="#666" strokeWidth="1"/>
                                                        {/* T5 */}
                                                        <text x="30" y="140" className="text-xs" textAnchor="end">T5</text>
                                                        <line x1="35" y1="137" x2="50" y2="137" stroke="#666" strokeWidth="1"/>
                                                        {/* T6 */}
                                                        <text x="370" y="140" className="text-xs" textAnchor="start">T6</text>
                                                        <line x1="350" y1="137" x2="365" y2="137" stroke="#666" strokeWidth="1"/>
                                                    </g>

                                                    {/* Processing time indicators */}
                                                    <line x1="350" y1="57" x2="350" y2="97" stroke="#666" strokeWidth="4" opacity="0.2"/>
                                                    <text x="370" y="80" className="text-xs" fill="#666">Processing</text>

                                                    {/* Message labels */}
                                                    <text x="200" y="45" textAnchor="middle" className="text-xs" fill="#10B981">Poll</text>
                                                    <text x="200" y="102" textAnchor="middle" className="text-xs" fill="#DC2626">Response</text>
                                                    <text x="200" y="135" textAnchor="middle" className="text-xs" fill="#6366F1">Final</text>

                                                    {/* Animated arrows */}
                                                    <g className="ranging-animation">
                                                        {/* Poll message (T1->T2) */}
                                                        <g>
                                                            <path d="M60,37 L340,57" stroke="#10B981" strokeWidth="2" strokeDasharray="290" strokeDashoffset="290" opacity="0">
                                                                <animate id="pollLineShow2" attributeName="opacity" values="0;1" dur="0.1s" begin="0s;resetAnim2.end" fill="freeze"/>
                                                                <animate id="pollAnim2" attributeName="stroke-dashoffset" from="290" to="0" dur="1.5s" begin="pollLineShow2.end" repeatCount="1"/>
                                                                <animate attributeName="stroke-dashoffset" to="290" dur="0.1s" begin="resetAnim2.end" fill="freeze"/>
                                                                <animate attributeName="opacity" values="1;0" dur="0.1s" begin="processAnim2.begin" fill="freeze"/>
                                                            </path>
                                                            {/* Moving arrow head for Poll */}
                                                            <path d="M0,0 l-8,4 v-8 z" fill="#10B981" opacity="0">
                                                                <animate attributeName="opacity" values="0;1" dur="0.1s" begin="pollLineShow2.end" fill="freeze"/>
                                                                <animate attributeName="opacity" values="1;0" dur="0.1s" begin="processAnim2.begin" fill="freeze"/>
                                                                <animateMotion dur="1.5s" begin="pollLineShow2.end" repeatCount="1"
                                                                    path="M60,37 L340,57" rotate="auto"/>
                                                            </path>
                                                        </g>

                                                        {/* Processing indication */}
                                                        <rect x="345" y="57" width="10" height="40" fill="#666" opacity="0">
                                                            <animate id="processAnim2" attributeName="opacity" values="0.2;0.5;0.2" dur="0.5s" begin="pollAnim2.end" repeatCount="2"/>
                                                        </rect>

                                                        {/* Response message (T3->T4) */}
                                                        <g>
                                                            <path d="M340,97 L60,117" stroke="#DC2626" strokeWidth="2" strokeDasharray="290" strokeDashoffset="290" opacity="0">
                                                                <animate id="responseLineShow2" attributeName="opacity" values="0;1" dur="0.1s" begin="processAnim2.end" fill="freeze"/>
                                                                <animate id="responseAnim2" attributeName="stroke-dashoffset" from="290" to="0" dur="1.5s" begin="responseLineShow2.end" repeatCount="1"/>
                                                                <animate attributeName="stroke-dashoffset" to="290" dur="0.1s" begin="resetAnim2.end" fill="freeze"/>
                                                                <animate attributeName="opacity" values="1;0" dur="0.1s" begin="finalLineShow2.begin" fill="freeze"/>
                                                            </path>
                                                            {/* Moving arrow head for Response */}
                                                            <path d="M0,0 l-8,4 v-8 z" fill="#DC2626" opacity="0">
                                                                <animate attributeName="opacity" values="0;1" dur="0.1s" begin="responseLineShow2.end" fill="freeze"/>
                                                                <animate attributeName="opacity" values="1;0" dur="0.1s" begin="finalLineShow2.begin" fill="freeze"/>
                                                                <animateMotion dur="1.5s" begin="responseLineShow2.end" repeatCount="1"
                                                                    path="M340,97 L60,117" rotate="auto"/>
                                                            </path>
                                                        </g>

                                                        {/* Final message (T5->T6) */}
                                                        <g>
                                                            <path d="M60,137 L340,137" stroke="#6366F1" strokeWidth="2" strokeDasharray="290" strokeDashoffset="290" opacity="0">
                                                                <animate id="finalLineShow2" attributeName="opacity" values="0;1" dur="0.1s" begin="responseAnim2.end+0.5s" fill="freeze"/>
                                                                <animate id="finalAnim2" attributeName="stroke-dashoffset" from="290" to="0" dur="1.5s" begin="finalLineShow2.end" repeatCount="1"/>
                                                                <animate attributeName="stroke-dashoffset" to="290" dur="0.1s" begin="resetAnim2.end" fill="freeze"/>
                                                                <animate attributeName="opacity" values="1;0" dur="0.1s" begin="resetAnim2.begin" fill="freeze"/>
                                                            </path>
                                                            {/* Moving arrow head for Final */}
                                                            <path d="M0,0 l-8,4 v-8 z" fill="#6366F1" opacity="0">
                                                                <animate attributeName="opacity" values="0;1" dur="0.1s" begin="finalLineShow2.end" fill="freeze"/>
                                                                <animate attributeName="opacity" values="1;0" dur="0.1s" begin="resetAnim2.begin" fill="freeze"/>
                                                                <animateMotion dur="1.5s" begin="finalLineShow2.end" repeatCount="1"
                                                                    path="M60,137 L340,137" rotate="auto"/>
                                                            </path>
                                                        </g>

                                                        {/* Arrival indicators */}
                                                        <circle cx="350" cy="57" r="3" fill="#10B981" opacity="0">
                                                            <animate attributeName="opacity" values="0;1" dur="0.1s" begin="pollAnim2.end" fill="freeze"/>
                                                            <animate attributeName="opacity" values="1;0" dur="0.1s" begin="processAnim2.end" fill="freeze"/>
                                                        </circle>
                                                        <circle cx="50" cy="117" r="3" fill="#DC2626" opacity="0">
                                                            <animate attributeName="opacity" values="0;1" dur="0.1s" begin="responseAnim2.end" fill="freeze"/>
                                                            <animate attributeName="opacity" values="1;0" dur="0.1s" begin="finalLineShow2.begin" fill="freeze"/>
                                                        </circle>
                                                        <circle cx="350" cy="137" r="3" fill="#6366F1" opacity="0">
                                                            <animate attributeName="opacity" values="0;1" dur="0.1s" begin="finalAnim2.end" fill="freeze"/>
                                                            <animate attributeName="opacity" values="1;0" dur="0.1s" begin="resetAnim2.begin" fill="freeze"/>
                                                        </circle>

                                                        {/* Animation reset trigger */}
                                                        <animate id="resetAnim2" attributeName="opacity" from="1" to="1" dur="0.1s" begin="finalAnim2.end+0.5s" repeatCount="1"/>
                                                    </g>
                                                </svg>
                                            </div>
                                            <div className="text-sm space-y-2">
                                                <p>Steps | 步驟：</p>
                                                <ol className="list-decimal list-inside space-y-1 pl-4">
                                                    <li>Initiator 發送 Poll 訊息 (T1)</li>
                                                    <li>Responder 接收到 Poll 訊息 (T2)</li>
                                                    <li>Responder 處理後發送 Response 訊息 (T3)</li>
                                                    <li>Initiator 接收到 Response 訊息 (T4)</li>
                                                    <li>Initiator 發送 Final 訊息 (T5)</li>
                                                    <li>Responder 接收到 Final 訊息 (T6)</li>
                                                </ol>
                                                <div className="katex-formula">
                                                    T<sub>prop</sub> = [(T<sub>4</sub> - T<sub>1</sub>)(T<sub>6</sub> - T<sub>3</sub>) - (T<sub>3</sub> - T<sub>2</sub>)(T<sub>5</sub> - T<sub>4</sub>)] / [2(T<sub>4</sub> - T<sub>1</sub> + T<sub>6</sub> - T<sub>3</sub>)]
                                                </div>
                                                <p className="text-xs text-gray-600 mt-2">
                                                    DS-ATWR 通過雙向測量和時鐘漂移補償，提供更高的測距精度
                                                </p>
                                            </div>
                                        </div>
                                    </div>

                                    <div>
                                        <p className="mb-1">Distance Calculation | 距離計算：</p>
                                        <MathDisplay tex="d = c \times t" displayMode={true} />
                                        <div className="text-xs text-gray-600 mt-1">
                                            Distance is calculated using Time of Flight (TOF) principle | 使用飛行時間原理計算距離：
                                            <br/>• d: distance between anchor and tag | 基站和標籤之間的距離
                                            <br/>• c: speed of light (≈ 3×10⁸ m/s) | 光速（約 3×10⁸ 米/秒）
                                            <br/>• t: time taken for signal to travel from anchor to tag and back | 信號從基站到標籤往返的時間
                                            <br/>UWB achieves high accuracy by precise time measurement in nanoseconds | UWB通過納秒級精確時間測量實現高精度
                                        </div>
                                    </div>

                                    <div>
                                        <p className="mb-1">Position Calculation | 位置計算：</p>
                                        <MathDisplay tex="(x-x_1)^2 + (y-y_1)^2 = d_1^2" displayMode={true} />
                                        <div className="text-xs text-gray-600 mt-1">
                                            Based on the circle equation, where | 基於圓方程，其中：
                                            <ul className="list-none space-y-1">
                                                <li className="flex items-center">
                                                    <MathDisplay tex="(x,y)" displayMode={false} /> : unknown tag position to be found | 待求的標籤位置
                                                </li>
                                                <li className="flex items-center">
                                                    <MathDisplay tex="(x_1,y_1)" displayMode={false} /> : known anchor position | 已知的基站位置
                                                </li>
                                                <li className="flex items-center">
                                                    <MathDisplay tex="d_1" displayMode={false} /> : measured distance between anchor and tag | 測量的基站和標籤之間距離
                                                </li>
                                            </ul>
                                            <p className="mt-2">Each anchor creates a circle, tag must lie on this circle | 每個基站形成一個圓，標籤必須位於圓上</p>
                                        </div>
                                    </div>

                                    {method === 'two' && (
                                        <div>
                                            <p className="mb-1">Two-point Positioning | 雙點定位：</p>
                                            <MathDisplay tex="\begin{cases} (x-x_1)^2 + (y-y_1)^2 = d_1^2 \\ (x-x_2)^2 + (y-y_2)^2 = d_2^2 \end{cases}" displayMode={true} />
                                            <div className="text-xs text-gray-600 mt-1">
                                                <ul className="list-disc pl-4 space-y-1">
                                                    <li className="flex items-center"><MathDisplay tex="(x,y)" displayMode={false} className="inline-block" />: Tag position | 標籤位置</li>
                                                    <li className="flex items-center"><MathDisplay tex="(x_1,y_1),(x_2,y_2)" displayMode={false} className="inline-block" />: Anchor positions | 基站位置</li>
                                                    <li className="flex items-center"><MathDisplay tex="d_1,d_2" displayMode={false} className="inline-block" />: Measured distances | 測量距離</li>
                                                </ul>
                                            </div>
                                        </div>
                                    )}

                                    {method === 'three' && (
                                        <div>
                                            <p className="mb-1">Trilateration | 三邊定位：</p>
                                            <MathDisplay tex="\begin{cases} (x-x_1)^2 + (y-y_1)^2 = d_1^2 \\ (x-x_2)^2 + (y-y_2)^2 = d_2^2 \\ (x-x_3)^2 + (y-y_3)^2 = d_3^2 \end{cases}" displayMode={true} />
                                            <div className="text-xs text-gray-600 mt-1">
                                                <ul className="list-disc pl-4 space-y-1">
                                                    <li className="flex items-center"><MathDisplay tex="(x,y)" displayMode={false} className="inline-block" />: Tag position | 標籤位置</li>
                                                    <li className="flex items-center"><MathDisplay tex="(x_1,y_1),(x_2,y_2),(x_3,y_3)" displayMode={false} className="inline-block" />: Anchor positions | 基站位置</li>
                                                    <li className="flex items-center"><MathDisplay tex="d_1,d_2,d_3" displayMode={false} className="inline-block" />: Measured distances | 測量距離</li>
                                                </ul>
                                            </div>
                                        </div>
                                    )}

                                    {method === 'many' && (
                                        <div>
                                            <p className="mb-1">Multilateration | 多邊定位：</p>
                                            <MathDisplay tex="\begin{cases} (x_t-x_1)^2 + (y_t-y_1)^2 = d_1^2 \\ (x_t-x_2)^2 + (y_t-y_2)^2 = d_2^2 \\ \vdots \\ (x_t-x_n)^2 + (y_t-y_n)^2 = d_n^2 \end{cases}" displayMode={true} />
                                            <div className="text-xs text-gray-600 mt-1 space-y-2">
                                                <div>
                                                    <p className="font-semibold mb-1">Basic Principles | 基本原理：</p>
                                                    <ul className="list-disc pl-4 space-y-1">
                                                        <li className="flex items-center"><MathDisplay tex="(x_t,y_t)" displayMode={false} className="inline-block" />: Tag position to be found | 待求的標籤位置</li>
                                                        <li className="flex items-center"><MathDisplay tex="(x_1,y_1), (x_2,y_2), \dots" displayMode={false} className="inline-block" />: Known anchor positions | 已知的基站位置</li>
                                                        <li className="flex items-center"><MathDisplay tex="d_1, d_2, \dots" displayMode={false} className="inline-block" />: Measured distances | 測量距離</li>
                                                    </ul>
                                                </div>
                                                <div>
                                                    <p className="font-semibold mb-1">Optimization Method | 優化方法：</p>
                                                    <ul className="list-disc pl-4 space-y-1">
                                                        <li>Uses least squares optimization | 使用最小二乘法優化</li>
                                                        <li>Minimizes sum of squared errors | 最小化誤差平方和</li>
                                                        <li>Iterative numerical solution | 迭代數值解算</li>
                                                    </ul>
                                                </div>
                                                <div>
                                                    <p className="font-semibold mb-1">Advantages | 優勢：</p>
                                                    <ul className="list-disc pl-4 space-y-1">
                                                        <li>Multiple anchors improve accuracy | 多基站提高精度</li>
                                                        <li>Redundant measurements reduce errors | 冗餘測量減少誤差</li>
                                                        <li>Better reliability with optimal anchor placement | 最佳基站布置提高可靠性</li>
                                                    </ul>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </CardContent>
                    </Card>
                </div>
            );
        };

        // 渲染應用
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<UWBVisualization />);
    </script>
</body>
</html>
