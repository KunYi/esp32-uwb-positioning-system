<!DOCTYPE html>
<html lang="zh-en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UWB Positioning Visualization | UWB 定位視覺化展示</title>
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" as="script">
    <link rel="preload" href="https://unpkg.com/react@18/umd/react.development.js" as="script">
    <link rel="preload" href="https://unpkg.com/react-dom@18/umd/react-dom.development.js" as="script">

    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 引入 React 和 ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: true,
                packages: ['base', 'ams', 'noerrors', 'noundefined']
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                typeset: true,
                ready: () => {
                    MathJax.startup.defaultReady();
                }
            },
            options: {
                enableMenu: false
            }
        };
    </script>
    <script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <style>
        .math-display {
            margin: 1em 0;
            overflow-x: auto;
        }
        .mjx-math {
            font-size: 1.1em;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const Card = ({ children, className }) => (
            <div className={`bg-white rounded-lg shadow-lg overflow-hidden ${className}`}>
                {children}
            </div>
        );

        const CardHeader = ({ children }) => (
            <div className="p-6 border-b">{children}</div>
        );

        const CardTitle = ({ children }) => (
            <h2 className="text-2xl font-bold mb-4">{children}</h2>
        );

        const CardContent = ({ children }) => (
            <div className="p-6">{children}</div>
        );

        const Select = ({ value, onChange, children }) => (
            <select
                value={value}
                onChange={(e) => onChange(e.target.value)}
                className="w-full p-2 border rounded-md bg-white"
            >
                {children}
            </select>
        );

        const Slider = ({ value, onChange, min, max, step }) => (
            <input
                type="range"
                value={value}
                onChange={(e) => onChange(parseFloat(e.target.value))}
                min={min}
                max={max}
                step={step}
                className="w-full"
            />
        );

        const MathDisplay = ({ tex, displayMode = true, className }) => {
            const containerRef = React.useRef(null);

            React.useEffect(() => {
                const renderMath = async () => {
                    if (!containerRef.current || !tex) return;

                    // 等待 MathJax 完全加載
                    if (!window.MathJax || !window.MathJax.typesetPromise) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        if (!window.MathJax || !window.MathJax.typesetPromise) {
                            console.warn('MathJax not loaded properly');
                            containerRef.current.textContent = tex;
                            return;
                        }
                    }

                    try {
                        containerRef.current.innerHTML = displayMode ? `$$${tex}$$` : `$${tex}$`;
                        await window.MathJax.typesetPromise([containerRef.current]);
                    } catch (err) {
                        console.error('MathJax rendering error:', err);
                        containerRef.current.textContent = tex;
                    }
                };

                renderMath();
            }, [tex, displayMode]);

            return <div ref={containerRef} className={`${className} math-display`}></div>;
        };

        const UWBVisualization = () => {
            const [method, setMethod] = React.useState('two');
            const [time, setTime] = React.useState(0);
            const [tagPosition, setTagPosition] = React.useState('inside');
            const [radius, setRadius] = React.useState(50);
            const [controlMode, setControlMode] = React.useState('auto');
            const [manualPosition, setManualPosition] = React.useState({ x: 200, y: 200 });
            const [isDragging, setIsDragging] = React.useState(false);
            const [angle, setAngle] = React.useState(0);  // 用於調整半徑的偏移量
            const svgRef = React.useRef(null);

            // 定義基站位置配置
            const anchorConfigs = {
                two: [
                    { x: 100, y: 200 },  // 左側基站
                    { x: 300, y: 200 },  // 右側基站，拉開距離
                ],
                three: [
                    { x: 133, y: 267 },  // 左側基站
                    { x: 267, y: 267 },  // 右側基站
                    { x: 200, y: 133 },  // 頂部基站
                ],
                many: [
                    { x: 100, y: 160 },  // 左上基站
                    { x: 300, y: 133 },  // 右上基站
                    { x: 300, y: 267 },  // 右下基站
                    { x: 100, y: 267 },  // 左下基站
                ]
            };

            // 處理拖曳開始
            const handleMouseDown = (e) => {
                if (controlMode === 'manual') {
                    setIsDragging(true);
                    const svg = svgRef.current;
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                    setManualPosition({ x: svgP.x, y: svgP.y });
                }
            };

            // 處理拖曳移動
            const handleMouseMove = (e) => {
                if (isDragging && controlMode === 'manual') {
                    const svg = svgRef.current;
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                    setManualPosition({ x: svgP.x, y: svgP.y });
                }
            };

            // 處理拖曳結束
            const handleMouseUp = () => {
                setIsDragging(false);
            };

            // 計算Tag位置
            const getTagPosition = () => {
                if (controlMode === 'manual') {
                    return manualPosition;
                }

                const centerX = 200;
                const centerY = 200;
                const radiusOffset = angle;  // 使用 angle 作為半徑的偏移量

                if (tagPosition === 'inside') {
                    return {
                        x: centerX + Math.cos(time * 0.1) * (radius + radiusOffset),
                        y: centerY + Math.sin(time * 0.1) * (radius + radiusOffset)
                    };
                } else {
                    return {
                        x: centerX + Math.cos(time * 0.1) * (radius + 100 + radiusOffset),
                        y: centerY + Math.sin(time * 0.1) * (radius + 100 + radiusOffset)
                    };
                }
            };

            // 像素轉換為米的比例（1像素 = 0.15米）
            const pixelToMeter = (pixels) => {
                const ratio = 0.15;
                return (pixels * ratio).toFixed(2);  // 保持兩位小數的精確度
            };

            // 格式化狀態文字
            const formatStatus = (value, unit = '') => {
                return `${value}${unit} | ${value}${unit}`;
            };

            // 計算兩點之間的距離
            const getDistance = (p1, p2) => {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                return Math.sqrt(dx * dx + dy * dy);
            };

            // 根據距離決定顏色
            const getDistanceColor = (distance) => {
                const maxGoodDistance = 200;  // 30米
                if (distance <= maxGoodDistance) {
                    return "rgba(0,255,0,0.2)";  // 綠色 - 良好範圍
                } else if (distance <= maxGoodDistance * 1.5) {
                    return "rgba(255,165,0,0.2)";  // 橙色 - 警告範圍
                } else {
                    return "rgba(255,0,0,0.2)";  // 紅色 - 較差範圍
                }
            };

            // 繪製圓形路徑
            const getCirclePath = (anchor, distance) => {
                return `M ${anchor.x} ${anchor.y} m -${distance}, 0 a ${distance},${distance} 0 1,0 ${distance*2},0 a ${distance},${distance} 0 1,0 -${distance*2},0`;
            };

            // 計算定位誤差
            const getPositioningError = () => {
                const tag = getTagPosition();
                const anchors = anchorConfigs[method];
                return anchors.reduce((sum, anchor) => {
                    const dx = tag.x - anchor.x;
                    const dy = tag.y - anchor.y;
                    return sum + Math.sqrt(dx * dx + dy * dy);
                }, 0) / anchors.length;
            };

            const tag = getTagPosition();

            // 動畫效果
            React.useEffect(() => {
                if (controlMode === 'auto') {
                    const timer = setInterval(() => {
                        setTime(prev => (prev + 1) % 100);
                    }, 50);
                    return () => clearInterval(timer);
                }
            }, [controlMode]);

            React.useEffect(() => {
                if (window.MathJax && window.MathJax.typeset) {
                    try {
                        window.MathJax.typeset();
                    } catch (err) {
                        console.error('MathJax error:', err);
                    }
                }
            }, [method]); // 當方法改變時重新渲染公式

            return (
                <div className="container mx-auto px-4 py-8">
                    <Card className="max-w-4xl mx-auto">
                        <CardHeader>
                            <CardTitle>UWB Positioning Demo (Inside/Outside Range) | UWB 定位演示（內部/外部範圍）</CardTitle>
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">
                                        Control Mode | 控制模式
                                    </label>
                                    <Select value={controlMode} onChange={setControlMode}>
                                        <option value="auto">Automatic Movement | 自動移動</option>
                                        <option value="manual">Manual Control (Drag) | 手動控制（拖曳）</option>
                                    </Select>
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">
                                        Positioning Method | 定位方法
                                    </label>
                                    <Select value={method} onChange={setMethod}>
                                        <option value="two">Two Anchors | 兩個基站</option>
                                        <option value="three">Three Anchors | 三個基站</option>
                                        <option value="many">Multiple Anchors | 多個基站</option>
                                    </Select>
                                </div>
                                {controlMode === 'auto' && (
                                    <div>
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-1">
                                                Tag Position | 標籤位置
                                            </label>
                                            <div className="mt-1">
                                                <input
                                                    type="range"
                                                    min="-10"
                                                    max="30"
                                                    value={angle}
                                                    onChange={(e) => setAngle(Number(e.target.value))}
                                                    className="w-full"
                                                />
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </CardHeader>
                        <CardContent>
                            <div className="relative w-full h-96 bg-slate-50 rounded-lg">
                                <svg
                                    width="100%"
                                    height="100%"
                                    viewBox="0 0 400 400"
                                    ref={svgRef}
                                    onMouseDown={handleMouseDown}
                                    onMouseMove={handleMouseMove}
                                    onMouseUp={handleMouseUp}
                                    onMouseLeave={handleMouseUp}
                                    style={{ cursor: controlMode === 'manual' ? 'grab' : 'default' }}
                                >
                                    {/* 覆蓋區域 */}
                                    <polygon
                                        points={anchorConfigs[method].map(p => `${p.x},${p.y}`).join(' ')}
                                        fill="rgba(0,0,255,0.1)"
                                        stroke="rgba(0,0,255,0.8)"
                                        strokeWidth="2"
                                    />

                                    {/* 基站之間的連線 */}
                                    {method === 'two' && (
                                        <line
                                            x1={anchorConfigs[method][0].x}
                                            y1={anchorConfigs[method][0].y}
                                            x2={anchorConfigs[method][1].x}
                                            y2={anchorConfigs[method][1].y}
                                            stroke="rgba(0,0,255,0.8)"
                                            strokeWidth="2"
                                        />
                                    )}
                                    {method === 'three' && anchorConfigs[method].map((anchor, i) => (
                                        <line
                                            key={i}
                                            x1={anchor.x}
                                            y1={anchor.y}
                                            x2={anchorConfigs[method][(i + 1) % 3].x}
                                            y2={anchorConfigs[method][(i + 1) % 3].y}
                                            stroke="rgba(0,0,255,0.8)"
                                            strokeWidth="2"
                                        />
                                    ))}
                                    {method === 'many' && (
                                        <g>
                                            <line x1={anchorConfigs[method][0].x} y1={anchorConfigs[method][0].y}
                                                  x2={anchorConfigs[method][1].x} y2={anchorConfigs[method][1].y}
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                            <line x1={anchorConfigs[method][1].x} y1={anchorConfigs[method][1].y}
                                                  x2={anchorConfigs[method][2].x} y2={anchorConfigs[method][2].y}
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                            <line x1={anchorConfigs[method][2].x} y1={anchorConfigs[method][2].y}
                                                  x2={anchorConfigs[method][3].x} y2={anchorConfigs[method][3].y}
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                            <line x1={anchorConfigs[method][3].x} y1={anchorConfigs[method][3].y}
                                                  x2={anchorConfigs[method][0].x} y2={anchorConfigs[method][0].y}
                                                  stroke="rgba(0,0,255,0.8)" strokeWidth="2" />
                                        </g>
                                    )}

                                    {/* 基站和距離圓 */}
                                    {anchorConfigs[method].map((anchor, index) => (
                                        <g key={index}>
                                            {/* 距離圓 */}
                                            <path
                                                d={getCirclePath(anchor, getDistance(anchor, tag))}
                                                fill="none"
                                                stroke={getDistanceColor(getDistance(anchor, tag))}
                                                strokeWidth="2"
                                            />
                                            {/* 基站點 */}
                                            <circle
                                                cx={anchor.x}
                                                cy={anchor.y}
                                                r="6"
                                                fill="blue"
                                            />
                                            <text
                                                x={anchor.x + 10}
                                                y={anchor.y - 10}
                                                fontSize="12"
                                            >
                                                Anchor {index + 1}
                                            </text>
                                            {/* 距離線 */}
                                            <line
                                                x1={anchor.x}
                                                y1={anchor.y}
                                                x2={tag.x}
                                                y2={tag.y}
                                                stroke="rgba(255,165,0,0.6)"
                                                strokeWidth="1.5"
                                                strokeDasharray="4,4"
                                            />
                                            {/* 距離文字背景 */}
                                            <rect
                                                x={(anchor.x + tag.x) / 2 - 25}
                                                y={(anchor.y + tag.y) / 2 - 10}
                                                width="50"
                                                height="20"
                                                fill="white"
                                                rx="4"
                                            />
                                            {/* 距離文字 */}
                                            <text
                                                x={(anchor.x + tag.x) / 2}
                                                y={(anchor.y + tag.y) / 2 + 5}
                                                fontSize="12"
                                                fill="black"
                                                textAnchor="middle"
                                            >
                                                {pixelToMeter(getDistance(anchor, tag))}m
                                            </text>
                                        </g>
                                    ))}

                                    {/* Tag */}
                                    <circle
                                        cx={tag.x}
                                        cy={tag.y}
                                        r="8"
                                        fill="red"
                                    />
                                    <text
                                        x={tag.x + 15}
                                        y={tag.y}
                                        fontSize="12"
                                    >
                                        Tag
                                    </text>
                                </svg>
                            </div>
                            <div className="mt-4 space-y-2 text-sm">
                                <p>Current Status | 當前狀態：{controlMode === 'manual' ? 'Manual Control | 手動控制' : 'Inside Range | 基站範圍內'}</p>
                                <p>Average Distance | 平均距離：{pixelToMeter(getPositioningError())}m</p>
                                {method === 'two' && (
                                    <p>Two-point Positioning | 雙點定位：
                                        {tagPosition === 'inside' ?
                                            'May have two solutions | 可能有兩個解' :
                                            'Positioning accuracy decreases when outside range | 在範圍外時定位精度下降'}
                                    </p>
                                )}
                                {method === 'three' && (
                                    <p>Three-Anchor Positioning | 三基站定位：
                                        {tagPosition === 'inside' ?
                                            'Unique solution available | 有唯一解' :
                                            'Solution may be less accurate outside range | 在範圍外時解可能不太準確'}
                                    </p>
                                )}
                                {method === 'many' && (
                                    <p>Multi-Anchor Positioning | 多基站定位：
                                        {tagPosition === 'inside' ?
                                            'Higher accuracy with redundant measurements | 冗餘測量提高精度' :
                                            'Better accuracy even outside range | 即使在範圍外也有較好的精度'}
                                    </p>
                                )}
                            </div>
                            {/* 定位原理說明 */}
                            <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                                <h3 className="font-bold mb-2">Positioning Principles | 定位原理</h3>
                                <div className="space-y-4">
                                    <div>
                                        <p className="mb-1">Distance Calculation | 距離計算：</p>
                                        <MathDisplay tex="d = c \times t" displayMode={true} />
                                        <p className="text-xs text-gray-600 mt-1">
                                            Distance is calculated using Time of Flight (TOF) principle | 使用飛行時間原理計算距離：
                                            <br/>• d: distance between anchor and tag | 基站和標籤之間的距離
                                            <br/>• c: speed of light (≈ 3×10⁸ m/s) | 光速（約 3×10⁸ 米/秒）
                                            <br/>• t: time taken for signal to travel from anchor to tag and back | 信號從基站到標籤往返的時間
                                            <br/>UWB achieves high accuracy by precise time measurement in nanoseconds | UWB通過納秒級精確時間測量實現高精度
                                        </p>
                                    </div>

                                    <div>
                                        <p className="mb-1">Position Calculation | 位置計算：</p>
                                        <MathDisplay tex="(x-x_1)^2 + (y-y_1)^2 = d_1^2" displayMode={true} />
                                        <p className="text-xs text-gray-600 mt-1">
                                            Based on the circle equation, where | 基於圓方程，其中：
                                            <li className="flex items-center"> <MathDisplay tex="(x,y)" displayMode={false} className="inline-block" />: unknown tag position to be found | 待求的標籤位置</li>
                                            <li className="flex items-center"> <MathDisplay tex="(x_1,y_1)" displayMode={false} className="inline-block" />: known anchor position | 已知的基站位置</li>
                                            <li className="flex items-center"> <MathDisplay tex="d_1" displayMode={false} className="inline-block" />: measured distance between anchor and tag | 測量的基站和標籤之間距離</li>
                                            <br/>Each anchor creates a circle, tag must lie on this circle | 每個基站形成一個圓，標籤必須位於圓上
                                        </p>
                                    </div>

                                    {method === 'two' && (
                                        <div>
                                            <p className="mb-1">Two-point Positioning | 雙點定位：</p>
                                            <MathDisplay tex="\begin{cases} (x-x_1)^2 + (y-y_1)^2 = d_1^2 \\ (x-x_2)^2 + (y-y_2)^2 = d_2^2 \end{cases}" displayMode={true} />
                                            <div className="text-xs text-gray-600 mt-1">
                                                <ul className="list-disc pl-4 space-y-1">
                                                    <li className="flex items-center"><MathDisplay tex="(x,y)" displayMode={false} className="inline-block" />: Tag position | 標籤位置</li>
                                                    <li className="flex items-center"><MathDisplay tex="(x_1,y_1),(x_2,y_2)" displayMode={false} className="inline-block" />: Anchor positions | 基站位置</li>
                                                    <li className="flex items-center"><MathDisplay tex="d_1,d_2" displayMode={false} className="inline-block" />: Measured distances | 測量距離</li>
                                                </ul>
                                            </div>
                                        </div>
                                    )}

                                    {method === 'three' && (
                                        <div>
                                            <p className="mb-1">Trilateration | 三邊定位：</p>
                                            <MathDisplay tex="\begin{cases} (x-x_1)^2 + (y-y_1)^2 = d_1^2 \\ (x-x_2)^2 + (y-y_2)^2 = d_2^2 \\ (x-x_3)^2 + (y-y_3)^2 = d_3^2 \end{cases}" displayMode={true} />
                                            <div className="text-xs text-gray-600 mt-1">
                                                <ul className="list-disc pl-4 space-y-1">
                                                    <li className="flex items-center"><MathDisplay tex="(x,y)" displayMode={false} className="inline-block" />: Tag position | 標籤位置</li>
                                                    <li className="flex items-center"><MathDisplay tex="(x_1,y_1),(x_2,y_2),(x_3,y_3)" displayMode={false} className="inline-block" />: Anchor positions | 基站位置</li>
                                                    <li className="flex items-center"><MathDisplay tex="d_1,d_2,d_3" displayMode={false} className="inline-block" />: Measured distances | 測量距離</li>
                                                </ul>
                                            </div>
                                        </div>
                                    )}

                                    {method === 'many' && (
                                        <div>
                                            <p className="mb-1">Multilateration | 多邊定位：</p>
                                            <MathDisplay tex="\begin{cases} (x_t-x_1)^2 + (y_t-y_1)^2 = d_1^2 \\ (x_t-x_2)^2 + (y_t-y_2)^2 = d_2^2 \\ \vdots \\ (x_t-x_n)^2 + (y_t-y_n)^2 = d_n^2 \end{cases}" displayMode={true} />
                                            <div className="text-xs text-gray-600 mt-1 space-y-2">
                                                <div>
                                                    <p className="font-semibold mb-1">Basic Principles | 基本原理：</p>
                                                    <ul className="list-disc pl-4 space-y-1">
                                                        <li className="flex items-center"><MathDisplay tex="(x_t,y_t)" displayMode={false} className="inline-block" />: Tag position to be found | 待求的標籤位置</li>
                                                        <li className="flex items-center"><MathDisplay tex="(x_1,y_1), (x_2,y_2), \dots" displayMode={false} className="inline-block" />: Known anchor positions | 已知的基站位置</li>
                                                        <li className="flex items-center"><MathDisplay tex="d_1, d_2, \dots" displayMode={false} className="inline-block" />: Measured distances | 測量距離</li>
                                                    </ul>
                                                </div>
                                                <div>
                                                    <p className="font-semibold mb-1">Optimization Method | 優化方法：</p>
                                                    <ul className="list-disc pl-4 space-y-1">
                                                        <li>Uses least squares optimization | 使用最小二乘法優化</li>
                                                        <li>Minimizes sum of squared errors | 最小化誤差平方和</li>
                                                        <li>Iterative numerical solution | 迭代數值解算</li>
                                                    </ul>
                                                </div>
                                                <div>
                                                    <p className="font-semibold mb-1">Advantages | 優勢：</p>
                                                    <ul className="list-disc pl-4 space-y-1">
                                                        <li>Multiple anchors improve accuracy | 多基站提高精度</li>
                                                        <li>Redundant measurements reduce errors | 冗餘測量減少誤差</li>
                                                        <li>Better reliability with optimal anchor placement | 最佳基站布置提高可靠性</li>
                                                    </ul>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </CardContent>
                    </Card>
                </div>
            );
        };

        // 渲染應用
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<UWBVisualization />);
    </script>
</body>
</html>
